@page "/game"
@using System.Text
@using System.Text.Json
@inject IJSRuntime JS
@inject HttpClient Http
@inject NavigationManager Nav
@rendermode InteractiveServer

<h3>Match ID: @gameData?.matchId</h3>

<div id="game-container">
    <!-- Map container -->
    <div id="map"></div>
    
<!--    @if (!IsGameOver)-->
    {
        <textarea id="hudTextArea" @bind="PlayerCommands" maxlength="6"></textarea>
        <div id="hudButtons">
            <button id="rotateLeftBtn">Rotate Left</button>
            <button id="rotateRightBtn">Rotate Right</button>
            <button id="forwardBtn">Forward</button>
            <button id="reverseBtn">Reverse</button>
            <button id="shootBtn">Shoot</button>
            <button id="deleteBtn">Delete</button>
            <button id="sendBtn" @onclick="SendPlayerInput">Send</button>
            <div id="countdownTimer">Time left: @CountDown seconds</div>
        </div>
        <div id="flashMessage" class="flash">Input limit reached!</div>
    }
<!--    else
    {
        <button class="btn btn-primary" @onclick="ReturnToHub">
            Return to Hub
        </button>
    } -->

</div>





@code {
    public class Tile
    {
        public int x { get; set; }
        public int y { get; set; }
        public string Type { get; set; }
    }
    
    public class MapData
    {
        public int map_width { get; set; }
        public int map_height { get; set; }
        public List<Tile> tiles { get; set; }
    }
    
    public class GameData
    {
        public string matchId { get; set; }
        public MapData map { get; set; }
        public List<Player> players { get; set; }
    }
    
    public class Player
    {
        public int id { get; set; }
        public int inGameId { get; set; }
        public int x { get; set; }
        public int y { get; set; }
        public string direction { get; set; }
        public string curInput { get; set; }
        // Additional properties needed
    }

    private string PlayerCommands { get; set; } = "";
    private int CountDown { get; set; } = 10; // For example, 10-second countdown
    private CancellationTokenSource pollingCts = new CancellationTokenSource();
    private int _lastProcessedRound = -1;
    private bool isGameOver = false;
    
    private async Task SendPlayerInput()
    {
        var gameId = gameData?.matchId;
        var sessionToken = await JS.InvokeAsync<string>("localStorage.getItem", "sessionToken");

        if (string.IsNullOrEmpty(gameId) || string.IsNullOrEmpty(sessionToken))
        {
            Console.WriteLine("Missing game ID or session token.");
            return;
        }

        // Fetch value from textarea manually to override stale `PlayerCommands`
        PlayerCommands = await JS.InvokeAsync<string>("eval", "document.getElementById('hudTextArea').value");
        Console.WriteLine($"playerCommands : {PlayerCommands}");

        string url = $"http://localhost:5000/api/game/{gameId}/inputs";
        var request = new HttpRequestMessage(HttpMethod.Put, url)
        {
            Content = new StringContent(JsonSerializer.Serialize(PlayerCommands), Encoding.UTF8, "application/json")
        };
        request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", sessionToken);

        try
        {
            var response = await Http.SendAsync(request);
            if (response.IsSuccessStatusCode)
            {
                Console.WriteLine("Server response: " + await response.Content.ReadAsStringAsync());
                PlayerCommands = "";
                StateHasChanged();
                _ = PollGameStatus(gameId, pollingCts.Token);
            }
            else
            {
                Console.WriteLine("Failed to send input: " + response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception sending input: " + ex.Message);
        }
    }

private async Task PollGameStatus(string gameId, CancellationToken token)
{
    Console.WriteLine("Started polling game status for gameId: " + gameId);
    var sessionToken = await JS.InvokeAsync<string>("localStorage.getItem", "sessionToken");
    
    while (!token.IsCancellationRequested)
    {
        try
        {
            using var request = new HttpRequestMessage(HttpMethod.Get, $"http://localhost:5000/api/game/{gameId}/status");
            request.Headers.Authorization = new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", sessionToken);
            
            var response = await Http.SendAsync(request, token);
            if (response.IsSuccessStatusCode)
            {
                var jsonString = await response.Content.ReadAsStringAsync(token);
                Console.WriteLine("Polling response: " + jsonString);
                
                using var roundResult = JsonDocument.Parse(jsonString);
                if (roundResult.RootElement.TryGetProperty("status", out var statusEl) &&
                    statusEl.TryGetProperty("round", out var roundEl))
                {
                    int roundNumber = 0;
                    if (roundEl.TryGetProperty("roundNumber", out var roundNumberEl))
                        roundNumber = roundNumberEl.GetInt32();

                    bool hasTurns = roundEl.TryGetProperty("turns", out var turnsEl) &&
                                    turnsEl.ValueKind == JsonValueKind.Array &&
                                    turnsEl.GetArrayLength() > 0;

                    Console.WriteLine($"Received roundNumber: {roundNumber}, hasTurns: {hasTurns}");
                    
                    if (hasTurns && roundNumber > _lastProcessedRound)
                    {
                        var roundJson = roundEl.GetRawText();
                        _lastProcessedRound = roundNumber;
                        await JS.InvokeVoidAsync("animateRound", roundJson);
                        break;
                    }
                    else
                    {
                        Console.WriteLine("Round not complete or same round, continuing to poll...");
                    }
                }
                else
                {
                    Console.WriteLine("No valid round output, continuing to poll...");
                }
            }
            else
            {
                Console.WriteLine("Polling request failed: " + response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception while polling: " + ex.Message);
        }
        await Task.Delay(2000, token);
    }
}




    private GameData gameData;
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            gameData = await JS.InvokeAsync<GameData>("window.localStore.getJson", "initialGameData");
            StateHasChanged();
            
            await JS.InvokeVoidAsync("startGameLoop", gameData);
        }
    }
    
    private async Task StartCountdownTimer(int duration)
    {
        CountDown = duration;
        while (CountDown > 0)
        {
            await Task.Delay(1000);
            CountDown--;
            StateHasChanged();
        }
        Console.WriteLine("Countdown timer finished");
        // Optionally, auto-send inputs when time runs out.
    }
}
