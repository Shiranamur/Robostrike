@page "/hub"
@inject HttpClient Http
@inject IJSRuntime JS
@inject NavigationManager Navigation
@rendermode InteractiveServer

<h3>Hub de jeu</h3>

<div class="hub-controls">
    <!-- Buttons disabled until JS is ready -->
    <button @onclick="JoinMatchmaking" disabled="@(jsInitialized ? null : true)">Rejoindre le matchmaking</button>
    <button @onclick="LeaveMatchmaking" disabled="@(jsInitialized ? null : true)">Quitter le matchmaking</button>
</div>

<div class="hub-status">
    <p>@statusMessage</p>
</div>

<!-- Game container to be updated by JS -->
<div id="gameContainer" style="width:480px; height:480px; border:1px solid #ccc;"></div>

@code {
    private string statusMessage = "Bienvenue sur le hub de jeu.";
    private string sessionToken = string.Empty;
    private bool jsInitialized = false;
    // Token pour annuler le long polling
    private CancellationTokenSource pollingCts;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Small delay to ensure scripts are loaded
            await Task.Delay(100);
            sessionToken = await JS.InvokeAsync<string>("localStore.get", "sessionToken");
            if (string.IsNullOrWhiteSpace(sessionToken))
            {
                Navigation.NavigateTo("/login");
                return;
            }
            else
            {
                statusMessage = "Token récupéré avec succès.";
            }
            jsInitialized = true;
            StateHasChanged();
        }
    }

    /// <summary>
    /// Appelle l'endpoint /api/matchmaking/join pour mettre le joueur dans la file,
    /// puis démarre le long polling sur /api/matchmaking/status.
    /// </summary>
    private async Task JoinMatchmaking()
    {
        try
        {
            if (!jsInitialized || string.IsNullOrWhiteSpace(sessionToken))
            {
                statusMessage = "Token de session introuvable.";
                Navigation.NavigateTo("/login");
                return;
            }

            Http.DefaultRequestHeaders.Authorization =
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", sessionToken);

            var joinResponse = await Http.GetAsync("http://localhost:5000/api/matchmaking/join");
            if (joinResponse.IsSuccessStatusCode)
            {
                statusMessage = await joinResponse.Content.ReadAsStringAsync();
                // Create a cancellation token for polling
                pollingCts = new CancellationTokenSource();
                await PollMatchmakingStatusAsync(pollingCts.Token);
            }
            else
            {
                statusMessage = $"Erreur lors du join: {joinResponse.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = ex.Message;
        }
    }

    /// <summary>
    /// Effectue le long polling sur l'endpoint /api/matchmaking/status.
    /// Si la réponse contient des informations de partie (game_id), on initialise l'interface du jeu.
    /// Sinon, s'il indique que le joueur est toujours en file, il réitère la requête après un délai.
    /// </summary>
    /// <param name="token">Le CancellationToken pour annuler le long polling.</param>
    private async Task PollMatchmakingStatusAsync(CancellationToken token)
    {
        bool gameFound = false;
        while (!gameFound && !token.IsCancellationRequested)
        {
            try
            {
                var statusResponse = await Http.GetAsync("http://localhost:5000/api/matchmaking/status", token);
                if (statusResponse.IsSuccessStatusCode)
                {
                    var resultJson = await statusResponse.Content.ReadAsStringAsync();
                    // If the response indicates game info (for instance, contains "game_id")
                    if (resultJson.Contains("game_id"))
                    {
                        statusMessage = $"Vous avez rejoint la partie : {resultJson}";

                        await JS.InvokeVoidAsync("initializeGameCanvas", "gameContainer");
                        gameFound = true;
                        StateHasChanged();
                        break;
                    }
                    else
                    {
                        statusMessage = "En attente... " + resultJson;
                        StateHasChanged();
                    }
                }
                else
                {
                    statusMessage = $"Erreur du statut: {statusResponse.StatusCode}";
                    StateHasChanged();
                }
            }
            catch (TaskCanceledException)
            {
                statusMessage = "Long polling annulé.";
                StateHasChanged();
                break;
            }
            catch (Exception ex)
            {
                statusMessage = ex.Message;
                StateHasChanged();
            }

            // Wait for 2 seconds before sending the next status request
            await Task.Delay(2000, token);
        }
    }

    /// <summary>
    /// Appelle l'endpoint /api/matchmaking/leave pour retirer le joueur de la file, et annule le long polling.
    /// </summary>
    private async Task LeaveMatchmaking()
    {
        try
        {
            pollingCts?.Cancel();

            Http.DefaultRequestHeaders.Authorization =
                new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", sessionToken);

            var leaveResponse = await Http.GetAsync("http://localhost:5000/api/matchmaking/leave");
            if (leaveResponse.IsSuccessStatusCode)
            {
                statusMessage = await leaveResponse.Content.ReadAsStringAsync();
            }
            else
            {
                statusMessage = $"Erreur lors du leave: {leaveResponse.StatusCode}";
            }
        }
        catch (Exception ex)
        {
            statusMessage = ex.Message;
        }
    }
}
